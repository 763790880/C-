--碎片整理
--删除并重建索引
--??用DROP INDEX和CREATE INDEX或ALTER TABLE来删除并重建索引有些缺陷包括在删除重建期间索引会消失。在索引删除重建时，对于查询它不再可用，查询性能也许会受到明显的影响，直到重建索引为止。另一个潜在的缺陷是当都请求索引的时候会引起阻塞，直到重建索引为止。通过其他的处理也能解决阻塞，就是索引被使用的时候不删除索引。另一个主要的缺陷是在用DROP INDEX和CREATE INDEX重建聚集索引时会引起非聚集索引重建两次。删除聚集索引时非聚集索引的行指针会指向数据堆，聚集索引重建时非聚集索引的行指针又会指回聚集索引的行位置。
--??删除并重建索引的确有一个好处就是通过重新排序索引页，使索引页紧凑并删除不需要的索引页来完全重建索引。你也许需要考虑那些内部和外部碎片都很高的情况下才使用，以使那些索引回到它们应该在的位置。

--使用DROP_EXISTING子句重建索引
--??为了避免在重建聚集索引时表上的非聚集索引重建两次，可以使用带DROP_EXISTING子句的CREATE INDEX语句。这个子句会保留聚集索引键值，以避免非聚集索引重建两次。和删除并重建索引一样，该方法也可能会引起阻塞和索引消失的问题。该方法的另一个缺陷是也强迫你去分别发现和修复表上的每一个索引。
--??除了和上一个方法一样的好处之外，该方法的好处是不必重建非聚集索引两次。这样可以对那些带约束的索引提供正确的索引定义以符合约束的要求。

--执行DBCC DBREINDEX
--??DBCC DBREINDEX类似于第二种方法，但它物理地重建索引，允许SQLServer给索引分配新页来减少内部和外部碎片。DBCC DBREINDEX也能动态的重建带约束的索引，不像第二种方法。
--??DBCC DBREINDEX的缺陷是会遇到或引起阻塞问题。DBCC DBREINDEX是作为一个事务来运行的，所以如果在完成之前中断了，那么你会丢失所有已经执行过的碎片。

--执行DBCC INDEXDEFRAG
--??DBCC INDEXDEFRAG（在SQLServer2000中可用）按照索引键的逻辑顺序，通过重新整理索引里存在的叶页来减少外部碎片，通过压缩索引页里的行然后删除那些由此产生的不需要的页来减少内部碎片。它不会遇到阻塞问题但它的结果没有其他几个方法彻底。这是因为DBCC INDEXDEFRAG跳过了锁定的页且不使用任何新页来重新排序索引。如果索引的碎片数量大的话你也许会发现DBCC INDEXDEFRAG比重建索引花费的时间更长。DBCC INDEXDEFRAG比其他方法的确有好处的是在其他过程访问索引时也能进行碎片整理，不会引起其他方法的阻塞问题。


 --改成当前库
use DB_Name
--创建变量 指定要查看的表
declare @table_id int
set @table_id=object_id('tb_Storage')
--执行--查看当前对应表的碎片查询情况
dbcc showcontig(@table_id)
--清理内部外部碎片
DBCC INDEXDEFRAG(Sunits_Inventory_demo,tb_Storage)

----INDEXDEFRAG 方法对应参数
--database_name| database_id | 0
--包含要进行碎片整理的索引的数据库。如果指定 0，则使用当前数据库。数据库名称必须符合标识符规则。

--table_name | table_id | view_name | view_id
--包含要进行碎片整理的索引的表或视图。表和视图的名称必须符合标识符规则。

--index_name |index_id
--要进行碎片整理的索引的名称或 ID。如果未指定，该语句将针对指定表或视图的所有索引进行碎片整理。索引名称必须符合标识符规则。

--partition_number | 0
--要进行碎片整理的索引的分区号。如果未指定或指定 0，该语句将对指定索引的所有分区进行碎片整理。

--WITH NO_INFOMSGS
--取消严重级别从 0 到 10 的所有信息性消息。




